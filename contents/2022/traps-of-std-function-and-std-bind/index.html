<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>std::function 和 std::bind 的使用陷阱 - ctj12461's Blog</title><meta name=author content="ctj12461"><meta name=author-link content><meta name=description content="std::function 和 std::bind 是 C++ 中非常常用的两个工具，然而要正确使用这两个工具还要更深入的理解。 最近写项目时遇到需要将不可复制构造的对象传给 std::bind 的情况，结果遇到了编"><meta name=keywords content="C++,标准库,函数对象,技术"><meta itemprop=name content="std::function 和 std::bind 的使用陷阱"><meta itemprop=description content="std::function 和 std::bind 是 C++ 中非常常用的两个工具，然而要正确使用这两个工具还要更深入的理解。 最近写项目时遇到需要将不可复制构造的对象传给 std::bind 的情况，结果遇到了编"><meta itemprop=datePublished content="2022-03-29T18:21:31+08:00"><meta itemprop=dateModified content="2022-03-29T18:21:31+08:00"><meta itemprop=wordCount content="1264"><meta itemprop=image content="https://ctj12461.github.io/logo.png"><meta itemprop=keywords content="C++,标准库,函数对象,技术,"><meta property="og:title" content="std::function 和 std::bind 的使用陷阱"><meta property="og:description" content="std::function 和 std::bind 是 C++ 中非常常用的两个工具，然而要正确使用这两个工具还要更深入的理解。 最近写项目时遇到需要将不可复制构造的对象传给 std::bind 的情况，结果遇到了编"><meta property="og:type" content="article"><meta property="og:url" content="https://ctj12461.github.io/blogs/contents/2022/traps-of-std-function-and-std-bind/"><meta property="og:image" content="https://ctj12461.github.io/logo.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-03-29T18:21:31+08:00"><meta property="article:modified_time" content="2022-03-29T18:21:31+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ctj12461.github.io/logo.png"><meta name=twitter:title content="std::function 和 std::bind 的使用陷阱"><meta name=twitter:description content="std::function 和 std::bind 是 C++ 中非常常用的两个工具，然而要正确使用这两个工具还要更深入的理解。 最近写项目时遇到需要将不可复制构造的对象传给 std::bind 的情况，结果遇到了编"><meta name=application-name content="ctj12461"><meta name=apple-mobile-web-app-title content="ctj12461"><meta name=theme-color data-light=#f8f8f8 data-dark=#252627 content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://ctj12461.github.io/blogs/contents/2022/traps-of-std-function-and-std-bind/><link rel=prev href=https://ctj12461.github.io/blogs/contents/2022/arch-linux-software-config/><link rel=next href=https://ctj12461.github.io/blogs/contents/2022/multigenerator-document/><link rel=stylesheet href=/blogs/css/style.min.css><link rel=stylesheet href=/blogs/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/blogs/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"std::function 和 std::bind 的使用陷阱","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/ctj12461.github.io\/blogs\/contents\/2022\/traps-of-std-function-and-std-bind\/"},"genre":"posts","keywords":"C\u002b\u002b, 标准库, 函数对象, 技术","wordcount":1264,"url":"https:\/\/ctj12461.github.io\/blogs\/contents\/2022\/traps-of-std-function-and-std-bind\/","datePublished":"2022-03-29T18:21:31+08:00","dateModified":"2022-03-29T18:21:31+08:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"ctj12461"},"description":""}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script>(window.localStorage?.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("data-theme","dark")</script><div class=wrapper><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper><div class=header-title><a href=/blogs/ title="ctj12461's Blog"><span class=header-title-text>ctj12461's Blog</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/blogs/posts/><i class="fas fa-archive fa-fw fa-sm"></i> 所有文章</a></li><li class=menu-item><a class=menu-link href=/blogs/tags/><i class="fas fa-tags fa-fw fa-sm"></i> 标签</a></li><li class=menu-item><a class=menu-link href=/blogs/categories/><i class="fas fa-th fa-fw fa-sm"></i> 分类</a></li><li class=menu-item><a class=menu-link href=/blogs/about/><i class="fas fa-info-circle fa-fw fa-sm"></i> 关于</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder="搜索文章标题或内容 ..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/blogs/ title="ctj12461's Blog"><span class=header-title-text>ctj12461's Blog</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="搜索文章标题或内容 ..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/blogs/posts/><i class="fas fa-archive fa-fw fa-sm"></i> 所有文章</a></li><li class=menu-item><a class=menu-link href=/blogs/tags/><i class="fas fa-tags fa-fw fa-sm"></i> 标签</a></li><li class=menu-item><a class=menu-link href=/blogs/categories/><i class="fas fa-th fa-fw fa-sm"></i> 分类</a></li><li class=menu-item><a class=menu-link href=/blogs/about/><i class="fas fa-info-circle fa-fw fa-sm"></i> 关于</a></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=container data-page-style=normal><aside class=toc id=toc-auto></aside><aside class=aside-custom></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>std::function 和 std::bind 的使用陷阱</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><span class=author><i class="fa-solid fa-user-circle" aria-hidden=true></i></span></span>
<span class=post-category>收录于 <a href=/blogs/categories/tech/><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> Tech</a></span></div><div class=post-meta-line><span title="2022-03-29 18:21:31"><i class="fa-regular fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2022-03-29>2022-03-29</time></span>&nbsp;<span><i class="fa-solid fa-pencil-alt fa-fw" aria-hidden=true></i> 约 1264 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw" aria-hidden=true></i> 预计阅读 3 分钟</span>&nbsp;</div></div><div class=content id=content><p><code>std::function</code> 和 <code>std::bind</code> 是 <code>C++</code> 中非常常用的两个工具，然而要正确使用这两个工具还要更深入的理解。</p><p>最近写项目时遇到需要将不可复制构造的对象传给 <code>std::bind</code> 的情况，结果遇到了编译错误。代码逻辑可以抽象为下面这样：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;functional&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Class</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Class</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Class</span><span class=p>(</span><span class=k>const</span> <span class=n>Class</span> <span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Class</span> <span class=o>&amp;</span><span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>Class</span> <span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Class</span><span class=p>(</span><span class=n>Class</span> <span class=o>&amp;&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Class</span> <span class=o>&amp;</span><span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>Class</span> <span class=o>&amp;&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>call</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>function</span><span class=o>&lt;</span><span class=kt>void</span><span class=p>()</span><span class=o>&gt;</span> <span class=n>func</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>func</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>func</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>bind</span><span class=p>([](</span><span class=n>Class</span> <span class=o>&amp;</span><span class=p>)</span> <span class=p>{</span> <span class=cm>/* code */</span> <span class=p>},</span> <span class=n>Class</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=n>call</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>func</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>这个错误 <code>Language Server</code> 是检测不到的，只有在编译后才能发现。编译错误信息如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>In file included from project.cpp:1:
</span></span><span class=line><span class=cl>In file included from /usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/11.2.0/../../../../include/c++/11.2.0/functional:59:
</span></span><span class=line><span class=cl>/usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/11.2.0/../../../../include/c++/11.2.0/bits/std_function.h:159:10: error: call to implicitly-deleted copy constructor of &#39;std::_Bind&lt;(lambda at project.cpp:19:27) (Class)&gt;&#39;
</span></span><span class=line><span class=cl>            new _Functor(*__source._M_access&lt;const _Functor*&gt;());
</span></span><span class=line><span class=cl>                ^        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</span></span><span class=line><span class=cl>/usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/11.2.0/../../../../include/c++/11.2.0/bits/std_function.h:196:8: note: in instantiation of member function &#39;std::_Function_base::_Base_manager&lt;std::_Bind&lt;(lambda at project.cpp:19:27) (Class)&gt;&gt;::_M_clone&#39; requested here
</span></span><span class=line><span class=cl>              _M_clone(__dest, __source, _Local_storage());
</span></span><span class=line><span class=cl>              ^
</span></span><span class=line><span class=cl>/usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/11.2.0/../../../../include/c++/11.2.0/bits/std_function.h:283:13: note: in instantiation of member function &#39;std::_Function_base::_Base_manager&lt;std::_Bind&lt;(lambda at project.cpp:19:27) (Class)&gt;&gt;::_M_manager&#39; requested here
</span></span><span class=line><span class=cl>            _Base::_M_manager(__dest, __source, __op);
</span></span><span class=line><span class=cl>                   ^
</span></span><span class=line><span class=cl>/usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/11.2.0/../../../../include/c++/11.2.0/bits/std_function.h:423:35: note: in instantiation of member function &#39;std::_Function_handler&lt;void (), std::_Bind&lt;(lambda at project.cpp:19:27) (Class)&gt;&gt;::_M_manager&#39; requested here
</span></span><span class=line><span class=cl>              _M_manager = &amp;_My_handler::_M_manager;
</span></span><span class=line><span class=cl>                                         ^
</span></span><span class=line><span class=cl>project.cpp:20:10: note: in instantiation of function template specialization &#39;std::function&lt;void ()&gt;::function&lt;std::_Bind&lt;(lambda at project.cpp:19:27) (Class)&gt;, void, void&gt;&#39; requested here
</span></span><span class=line><span class=cl>    call(std::move(func));
</span></span><span class=line><span class=cl>         ^
</span></span><span class=line><span class=cl>/usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/11.2.0/../../../../include/c++/11.2.0/functional:493:7: note: explicitly defaulted function was implicitly deleted here
</span></span><span class=line><span class=cl>      _Bind(const _Bind&amp;) = default;
</span></span><span class=line><span class=cl>      ^
</span></span><span class=line><span class=cl>/usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/11.2.0/../../../../include/c++/11.2.0/functional:412:29: note: copy constructor of &#39;_Bind&lt;(lambda at project.cpp:19:27) (Class)&gt;&#39; is implicitly deleted because field &#39;_M_bound_args&#39; has a deleted copy constructor
</span></span><span class=line><span class=cl>      tuple&lt;_Bound_args...&gt; _M_bound_args;
</span></span><span class=line><span class=cl>                            ^
</span></span><span class=line><span class=cl>/usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/11.2.0/../../../../include/c++/11.2.0/tuple:744:17: note: explicitly defaulted function was implicitly deleted here
</span></span><span class=line><span class=cl>      constexpr tuple(const tuple&amp;) = default;
</span></span><span class=line><span class=cl>                ^
</span></span><span class=line><span class=cl>/usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/11.2.0/../../../../include/c++/11.2.0/tuple:599:19: note: copy constructor of &#39;tuple&lt;Class&gt;&#39; is implicitly deleted because base class &#39;_Tuple_impl&lt;0, Class&gt;&#39; has a deleted copy constructor
</span></span><span class=line><span class=cl>    class tuple : public _Tuple_impl&lt;0, _Elements...&gt;
</span></span><span class=line><span class=cl>                  ^
</span></span><span class=line><span class=cl>/usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/11.2.0/../../../../include/c++/11.2.0/tuple:435:17: note: explicitly defaulted function was implicitly deleted here
</span></span><span class=line><span class=cl>      constexpr _Tuple_impl(const _Tuple_impl&amp;) = default;
</span></span><span class=line><span class=cl>                ^
</span></span><span class=line><span class=cl>/usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/11.2.0/../../../../include/c++/11.2.0/tuple:408:7: note: copy constructor of &#39;_Tuple_impl&lt;0, Class&gt;&#39; is implicitly deleted because base class &#39;_Head_base&lt;0UL, Class&gt;&#39; has a deleted copy constructor
</span></span><span class=line><span class=cl>    : private _Head_base&lt;_Idx, _Head&gt;
</span></span><span class=line><span class=cl>      ^
</span></span><span class=line><span class=cl>/usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/11.2.0/../../../../include/c++/11.2.0/tuple:86:17: note: explicitly defaulted function was implicitly deleted here
</span></span><span class=line><span class=cl>      constexpr _Head_base(const _Head_base&amp;) = default;
</span></span><span class=line><span class=cl>                ^
</span></span><span class=line><span class=cl>/usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/11.2.0/../../../../include/c++/11.2.0/tuple:125:39: note: copy constructor of &#39;_Head_base&lt;0, Class, true&gt;&#39; is implicitly deleted because field &#39;_M_head_impl&#39; has a deleted copy constructor
</span></span><span class=line><span class=cl>      [[__no_unique_address__]] _Head _M_head_impl;
</span></span><span class=line><span class=cl>                                      ^
</span></span><span class=line><span class=cl>project.cpp:7:5: note: &#39;Class&#39; has been explicitly marked deleted here
</span></span><span class=line><span class=cl>    Class(const Class &amp;) = delete;
</span></span><span class=line><span class=cl>    ^
</span></span><span class=line><span class=cl>1 error generated.
</span></span></code></pre></td></tr></table></div></div><p>这个编译信息具有一定的误导性，有可能首先会想到的是 <code>std::bind</code> 生成的函数对象不支持复制构造和移动构造，但实际上查看源码后发现，<code>std::bind</code> 返回一个 <code>_Bind&lt;_Signature></code> 类，其中一个特化为：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>_Functor</span><span class=p>,</span> <span class=k>typename</span><span class=p>...</span> <span class=n>_Bound_args</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>_Bind</span><span class=o>&lt;</span><span class=n>_Functor</span><span class=p>(</span><span class=n>_Bound_args</span><span class=p>...)</span><span class=o>&gt;</span> <span class=o>:</span> <span class=k>public</span> <span class=n>_Weak_result_type</span><span class=o>&lt;</span><span class=n>_Functor</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>_Functor</span> <span class=n>_M_f</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>tuple</span><span class=o>&lt;</span><span class=n>_Bound_args</span><span class=p>...</span><span class=o>&gt;</span> <span class=n>_M_bound_args</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>其中 <code>_M_f</code> 在这里是编译器将 <code>lambda</code> 表达式转换后的函数对象，复制构造和移动构造都可以支持，<code>_M_bound_args</code> 则是绑定的参数，使用 <code>std::tuple</code> 实现，其复制构造函数和移动构造函数均为 <code>= default</code>，所以至少移动构造函数也是可用的，也就是 <code>std::bind</code> 返回的这个函数对象 <code>_Bind&lt;_Signature></code> 也是可以移动构造的，因此 <code>std::move(func)</code> 是没有问题的。</p><p>所以问题出在 <code>std::function</code> 上，再查看 <code>std::function</code> 的源码，找到其构造函数对其他函数对象的重载：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>_Functor</span><span class=p>,</span> <span class=k>typename</span> <span class=o>=</span> <span class=cm>/* ... */</span><span class=p>,</span> <span class=k>typename</span> <span class=o>=</span> <span class=cm>/* ... */</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>function</span><span class=p>(</span><span class=n>_Functor</span> <span class=n>__f</span><span class=p>)</span> <span class=o>:</span> <span class=n>_Function_base</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>typedef</span> <span class=n>_Function_handler</span><span class=o>&lt;</span><span class=n>_Res</span><span class=p>(</span><span class=n>_ArgTypes</span><span class=p>...),</span> <span class=n>_Functor</span><span class=o>&gt;</span> <span class=n>_My_handler</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>_My_handler</span><span class=o>::</span><span class=n>_M_not_empty_function</span><span class=p>(</span><span class=n>__f</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>_My_handler</span><span class=o>::</span><span class=n>_M_init_functor</span><span class=p>(</span><span class=n>_M_functor</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>__f</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>_M_invoker</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>_My_handler</span><span class=o>::</span><span class=n>_M_invoke</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>_M_manager</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>_My_handler</span><span class=o>::</span><span class=n>_M_manager</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>如果 <code>std::function</code> 接受了一个函数对象，那么就会使用 <code>_My_handler::_M_init_functor(_M_functor, std::move(__f))</code> 将该函数对象复制到自身内部的 <code>_M_functor</code> 成员上，而这个函数最终会调用以下两个函数之一：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>_M_init_functor</span><span class=p>(</span><span class=n>_Any_data</span> <span class=o>&amp;</span><span class=n>__functor</span><span class=p>,</span> <span class=n>_Functor</span> <span class=o>&amp;&amp;</span><span class=n>__f</span><span class=p>,</span> <span class=n>true_type</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>::</span><span class=k>new</span> <span class=p>(</span><span class=n>__functor</span><span class=p>.</span><span class=n>_M_access</span><span class=p>())</span> <span class=n>_Functor</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>__f</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>_M_init_functor</span><span class=p>(</span><span class=n>_Any_data</span> <span class=o>&amp;</span><span class=n>__functor</span><span class=p>,</span> <span class=n>_Functor</span> <span class=o>&amp;&amp;</span><span class=n>__f</span><span class=p>,</span> <span class=n>false_type</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>__functor</span><span class=p>.</span><span class=n>_M_access</span><span class=o>&lt;</span><span class=n>_Functor</span> <span class=o>*&gt;</span><span class=p>()</span> <span class=o>=</span> <span class=k>new</span> <span class=n>_Functor</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>__f</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>事实上也只会调用以上这几个函数，这个过程也都是移动构造，理论上即使删除了复制构造函数也是可以正常工作的，其实问题出在其他函数使用了复制，比如下面这对：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>_M_clone</span><span class=p>(</span><span class=n>_Any_data</span> <span class=o>&amp;</span><span class=n>__dest</span><span class=p>,</span> <span class=k>const</span> <span class=n>_Any_data</span> <span class=o>&amp;</span><span class=n>__source</span><span class=p>,</span> <span class=n>true_type</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>::</span><span class=k>new</span> <span class=p>(</span><span class=n>__dest</span><span class=p>.</span><span class=n>_M_access</span><span class=p>())</span> <span class=n>_Functor</span><span class=p>(</span><span class=n>__source</span><span class=p>.</span><span class=n>_M_access</span><span class=o>&lt;</span><span class=n>_Functor</span><span class=o>&gt;</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>_M_clone</span><span class=p>(</span><span class=n>_Any_data</span> <span class=o>&amp;</span><span class=n>__dest</span><span class=p>,</span> <span class=k>const</span> <span class=n>_Any_data</span> <span class=o>&amp;</span><span class=n>__source</span><span class=p>,</span> <span class=n>false_type</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>__dest</span><span class=p>.</span><span class=n>_M_access</span><span class=o>&lt;</span><span class=n>_Functor</span> <span class=o>*&gt;</span><span class=p>()</span> <span class=o>=</span> <span class=k>new</span> <span class=n>_Functor</span><span class=p>(</span><span class=o>*</span><span class=n>__source</span><span class=p>.</span><span class=n>_M_access</span><span class=o>&lt;</span><span class=k>const</span> <span class=n>_Functor</span> <span class=o>*&gt;</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>这里 <code>__source._M_access&lt;_Functor>()</code> 显然不是右值，只能调用复制构造函数。而模板实例化是全部的，不是只对有使用到的代码进行处理。结论就是不可以用 <code>std::function</code> 保存不可复制构造的函数对象，包括这种 <code>std::bind</code>，因此解决方案也就是不使用 <code>std::function</code>。然而这样就不容易对函数签名进行限制，比如下面的这种方法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;functional&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Class</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Class</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Class</span><span class=p>(</span><span class=k>const</span> <span class=n>Class</span> <span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Class</span> <span class=o>&amp;</span><span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>Class</span> <span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Class</span><span class=p>(</span><span class=n>Class</span> <span class=o>&amp;&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Class</span> <span class=o>&amp;</span><span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>Class</span> <span class=o>&amp;&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>Functor</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>call</span><span class=p>(</span><span class=n>Functor</span> <span class=n>func</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>func</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>func</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>bind</span><span class=p>([](</span><span class=n>Class</span> <span class=o>&amp;</span><span class=p>)</span> <span class=p>{</span> <span class=cm>/* code */</span> <span class=p>},</span> <span class=n>Class</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=n>call</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>func</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="2022-03-29 18:21:31">更新于 2022-03-29&nbsp;</span></div><div class=post-info-license><span>本文以 CC BY-NC 4.0 许可证发布</span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=https://ctj12461.github.io/blogs/contents/2022/traps-of-std-function-and-std-bind/ data-title="std::function 和 std::bind 的使用陷阱" data-hashtags=C++,标准库,函数对象,技术><i class="fa-brands fa-twitter fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://ctj12461.github.io/blogs/contents/2022/traps-of-std-function-and-std-bind/ data-hashtag=C++><i class="fa-brands fa-facebook-square fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 WhatsApp" data-sharer=whatsapp data-url=https://ctj12461.github.io/blogs/contents/2022/traps-of-std-function-and-std-bind/ data-title="std::function 和 std::bind 的使用陷阱" data-web><i class="fa-brands fa-whatsapp fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Line" data-sharer=line data-url=https://ctj12461.github.io/blogs/contents/2022/traps-of-std-function-and-std-bind/ data-title="std::function 和 std::bind 的使用陷阱"><i data-svg-src=/blogs/lib/simple-icons/icons/line.min.svg aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://ctj12461.github.io/blogs/contents/2022/traps-of-std-function-and-std-bind/ data-title="std::function 和 std::bind 的使用陷阱"><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Myspace" data-sharer=myspace data-url=https://ctj12461.github.io/blogs/contents/2022/traps-of-std-function-and-std-bind/ data-title="std::function 和 std::bind 的使用陷阱" data-description><i data-svg-src=/blogs/lib/simple-icons/icons/myspace.min.svg aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Blogger" data-sharer=blogger data-url=https://ctj12461.github.io/blogs/contents/2022/traps-of-std-function-and-std-bind/ data-title="std::function 和 std::bind 的使用陷阱" data-description><i class="fa-brands fa-blogger fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Evernote" data-sharer=evernote data-url=https://ctj12461.github.io/blogs/contents/2022/traps-of-std-function-and-std-bind/ data-title="std::function 和 std::bind 的使用陷阱"><i class="fa-brands fa-evernote fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/blogs/tags/c++/>C++</a>,&nbsp;<a href=/blogs/tags/%E6%A0%87%E5%87%86%E5%BA%93/>标准库</a>,&nbsp;<a href=/blogs/tags/%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1/>函数对象</a>,&nbsp;<a href=/blogs/tags/%E6%8A%80%E6%9C%AF/>技术</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/blogs/>主页</a></span></section></div><div class=post-nav><a href=/blogs/contents/2022/arch-linux-software-config/ class=prev rel=prev title="Arch Linux 常用软件配置"><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>Arch Linux 常用软件配置</a>
<a href=/blogs/contents/2022/multigenerator-document/ class=next rel=next title="MultiGenerator 使用文档">MultiGenerator 使用文档<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></main><footer class=footer><div class=footer-container><div class="footer-line powered">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.105.0">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.2.17-RC"><img class=fixit-icon src=/blogs/fixit.min.svg alt="FixIt logo">&nbsp;FixIt</a></div><div class="footer-line copyright" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2022</span><span class=author itemprop=copyrightHolder>
<a href=/blogs/>ctj12461</a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div><div class="footer-line statistics"><span class=site-time title='网站运行中 ...'><i class="fa-solid fa-heartbeat fa-fw animate-icon" aria-hidden=true></i>&nbsp;<span class=run-times>网站运行中 ...</span></span></div><div class="footer-line ibruce"><span id=busuanzi_container_site_uv title=总访客数><i class="fa-regular fa-user fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_uv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span><span id=busuanzi_container_site_pv class=footer-divider title=总访问量><i class="fa-regular fa-eye fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_pv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class=variant-numeric>0%</span></div></div><div id=mask></div><noscript><div class=noscript-warning>FixIt 主题在启用 JavaScript 的情况下效果最佳。</div></noscript></div><script src=/blogs/lib/autocomplete/autocomplete.min.js defer></script><script src=/blogs/lib/lunr/lunr.min.js defer></script><script src=/blogs/lib/lunr/lunr.stemmer.support.min.js defer></script><script src=/blogs/lib/lunr/lunr.zh.min.js defer></script><script src=/blogs/lib/lazysizes/lazysizes.min.js async defer></script><script src=/blogs/lib/sharer/sharer.min.js async defer></script><script src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async defer></script><script>window.config={code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:1e4},comment:{enable:!1},enablePWA:!0,search:{highlightTag:"em",lunrIndexURL:"/blogs/index.json",lunrLanguageCode:"zh",lunrSegmentitURL:"/blogs/lib/lunr/lunr.segmentit.js",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"lunr"},siteTime:"2022-02-04T18:00:00+08:00"}</script><script src=/blogs/js/theme.min.js defer></script></body></html>